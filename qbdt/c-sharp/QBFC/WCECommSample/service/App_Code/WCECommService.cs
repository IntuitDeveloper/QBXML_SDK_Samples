using System;
using System.Web;
using System.Web.Services;
using System.Web.Services.Protocols;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.IO;
using System.Security.Cryptography;
using Microsoft.Win32;
using System.Xml;
using System.Text.RegularExpressions;
using System.Net;
using System.Collections;

/* 
 * Important Note: 	
 * You should keep the namespace as http://developer.intuit.com/ for all 
 * services that communicate with QuickBooks Web Connector
 * 
 * Useful note about using OwnerID and FileID in a real-world application 
 * As part of your QB Web Connector configuration (.QWC) file, you include 
 * OwnerID and FileID. Following note on these two parameters may be useful.  
 * 
 * OwnerID -- this is a GUID that represents your application or suite 
 * applications, if your application needs to store private data in the  
 * company file for one reason or another (one of the most common cases  
 * being to check if you have communicated with this company file before
 * and possibly some data about that communication) that private data 
 * be visible to any application that knows the OwnerID
 * 
 * FileID -- this is a GUID we stamp in the file on your (using your OwnerID) 
 * as a private data extension to the "Company" object
 * It allows an application to verify that the company file it is 
 * data with is consistent over time (by doing a CompanyQuery with the 
 * set appropriately and reading the DataExtRet values returned.  
*/

/// <summary>
/// Sample WebService in ASP.NET to demonstrate QuickBooks WebConnector.
/// </summary>

[WebService(
     Namespace      = "http://developer.intuit.com/",
     Name           = "WCECommService",
     Description    = "Sample WebService in ASP.NET to demonstrate " +
                      "QuickBooks WebConnector")]

public class WCECommService : System.Web.Services.WebService
{
   	//Private Variables
	private AccessDatabase db                   = new AccessDatabase();
    private IAuthentication authenticator       = (IAuthentication)new SampleAuthentication();
    private ISessionPool sessionPool            = (ISessionPool)MemorySession.Instance;
    private IController controller              = (IController)new SampleController();
    private static bool doLogging               = false; //For debugging
    private System.Diagnostics.EventLog evLog   = new System.Diagnostics.EventLog();

	//Constructor
	public WCECommService()
		{
			//CODEGEN: This call is required by the ASP.NET 
			//Web Services Designer
			InitializeComponent();
			// Initializing EventLog for logging
			initEvLog();
		}

	#region AutoGeneratedMethods
	//Required by the Web Services Designer 
	private IContainer components = null;
			
	/// <summary>
	/// Required method for Designer support - do not modify
	/// the contents of this method with the code editor.
	/// </summary>
	private void InitializeComponent()
	{
	}

	/// <summary>
	/// Clean up any resources being used.
	/// </summary>
	protected override void Dispose( bool disposing )
	{
		if(disposing && components != null)
		{
			components.Dispose();
		}
		base.Dispose(disposing);		
	}
	#endregion

	// WebMethods
    [WebMethod(Description = "This web method enables web service with QBWC version control.", EnableSession = true)]
    /// <summary>
	/// WebMethod - clientVersion()
	/// To enable web service with QBWC version control
	/// Signature: public string clientVersion(string strVersion)
	///
	/// IN: 
	/// string strVersion
	///
	/// OUT: 
	/// string errorOrWarning
	/// Possible values: 
	/// string retVal
	/// - NULL or <emptyString> = QBWC will let the web service update
	/// - "E:<any text>" = popup ERROR dialog with <any text> 
	///					- abort update and force download of new QBWC.
	/// - "W:<any text>" = popup WARNING dialog with <any text> 
	///					- choice to user, continue update or not.
	/// </summary>
    public string clientVersion(string strVersion)
		{
			logEnter("clientVersion()", new string[,] { {"strVersion", strVersion} });
            string retVal=null;
			double recommendedVersion  = 2.0;
			double supportedMinVersion = 2.0;
			double suppliedVersion=Convert.ToDouble(this.parseForVersion(strVersion));
            if (suppliedVersion < supportedMinVersion) { 
                retVal = "E:You need to upgrade your QBWebConnector"; 
            } 
            else if(suppliedVersion < recommendedVersion) { 
                retVal="W:We recommend that you upgrade your QBWebConnector"; 
            }
            logExit("clientVersion()", new string[,] { { "retVal(string)", retVal } });
            return retVal;
		}




    [WebMethod(Description = "This web method facilitates verify username and password for the web connector that is trying to connect to this service.", EnableSession = true)]
    /// <summary>
    /// WebMethod - authenticate()
    /// To verify username and password for the web connector that is trying to connect
    /// Signature: public string[] authenticate(string strUserName, string strPassword)
    /// 
    /// IN: 
    /// string strUserName 
    /// string strPassword
    ///
    /// OUT: 
    /// string[] authReturn
    /// Possible values: 
    /// string[0] = ticket
    /// string[1]
    /// - "" = use current company file
    /// - "none" = no further request/no further action required
    /// - "nvu" = not valid user
    /// - "use this string as the company file path" = use this company file
    /// string[2] - (optional) contains the number of seconds to wait before 
    /// the next update.
    /// string[3] - (optional) contains the number of seconds to be used as the 
    /// MinimumRunEveryNSeconds time.
    /// 
    /// The third and fourth elements allow you to to reduce QBWC updates during 
    /// peak activity, basically telling QBWC clients not to update so frequently 
    /// (the third element) or permanently resetting the minimum update time at the 
    /// QBWC client (the fourth element).
    /// </summary>
    public string[] authenticate(string strUserName, string strPassword)
		{
            logEnter("authenticate()", new string[,] { { "strUserName", strUserName }, { "strPassword", strPassword} });
            string[] authReturn = initAuthResponse();
            Session sess = new Session(authReturn[0], strUserName, strPassword);
            try {
                doAuthenticate(strUserName, strPassword, ref authReturn);
                checkWork(ref authReturn, sess);
            }
            catch (AuthenticateExceptionInvalid e) {
                logEvent(e.Message);
                authReturn=setAuthResponse("", "nvu");
                sess = null;
            }
            catch (Exception e2) {
                logEvent(e2.Message);
                authReturn = setAuthResponse("", "none");
                sess = null;
            }
            if(sess!=null) sessionPool.put(authReturn[0], sess);
            logExit("authenticate()", new string[,] { { "authReturn[0]", authReturn[0] }, { "authReturn[1]", authReturn[1] } });
            return authReturn;
		}
    




		
	[ WebMethod(Description="This web method facilitates web service to handle connection error between QuickBooks and QBWebConnector",EnableSession=true) ]
	/// <summary>
	/// WebMethod - connectionError()
	/// To facilitate capturing of QuickBooks error and notifying it to web services
	/// Signature: public string connectionError (string ticket, string hresult, string message)
	///
	/// IN: 
	/// string ticket = A GUID based ticket string to maintain identity of QBWebConnector 
	/// string hresult = An HRESULT value thrown by QuickBooks when trying to make connection
	/// string message = An error message corresponding to the HRESULT
	///
	/// OUT:
	/// string retVal
	/// Possible values: 
	/// - “done” = no further action required from QBWebConnector
	/// - any other string value = use this name for company file
	/// </summary>
    public string connectionError(string ticket, string hresult, string message)
	{
        logEnter("connectionError()", new string[,] { { "ticket", ticket }, { "hresult", hresult }, { "message", message } });
        Session sess = sessionPool.get(ticket);
        int ce_counter = 0;     // We must not get into an infinte loop, so we count our errors
        if (sess != null & sess.getProperty("ce_counter") != null) {
			ce_counter = (int)sess.getProperty("ce_counter");
        }
        string retVal = interpretHResult(hresult, message, ce_counter);
        sess.setProperty("ce_counter", ce_counter+1);
        sessionPool.put(ticket, sess);
        logExit("connectionError()", new string[,] { { "retVal", retVal } });
        return retVal;
	}




	
    [ WebMethod(Description="This web method facilitates web service to send request XML to QuickBooks via QBWebConnector",EnableSession=true) ]
	/// <summary>
	/// WebMethod - sendRequestXML()
	/// Signature: public string sendRequestXML(string ticket, string strHCPResponse, string strCompanyFileName, 
	/// string qbXMLCountry, int qbXMLMajorVers, int qbXMLMinorVers)
	/// 
	/// IN: 
	/// string ticket
	/// string strHCPResponse 
	/// string strCompanyFileName 
	/// string qbXMLCountry
	/// int qbXMLMajorVers
	/// int qbXMLMinorVers
	///
	/// OUT:
	/// string request
	/// Possible values: 
	/// - “any_string” = Request XML for QBWebConnector to process
	/// - "" = No more request XML 
	/// </summary>
	public string sendRequestXML(string ticket, string strHCPResponse, string strCompanyFileName, 
		string qbXMLCountry, int qbXMLMajorVers, int qbXMLMinorVers)
	{
        logEnter("sendRequestXML()", new string[,] { { "ticket", ticket }, { "strHCPResponse", strHCPResponse}, 
            { "strCompanyFile", strCompanyFileName }, { "qbXMLCountry", qbXMLCountry }, 
            { "qbXMLMajorVers", qbXMLMajorVers.ToString() }, { "qbXMLMinorVers", qbXMLMinorVers.ToString() }});
        Session sess = sessionPool.get(ticket);
        string request = "";
        sess.defineSession(strCompanyFileName, qbXMLCountry, (short)qbXMLMajorVers, (short)qbXMLMinorVers);
        request = controller.getNextAction(sess);
        sessionPool.put(ticket, sess);
        logExit("sendRequestXML()", new string[,] { { "request", request } });
        return request;
	}


	
	
    
    [ WebMethod(Description="This web method facilitates web service to receive response XML from QuickBooks via QBWebConnector",EnableSession=true) ]
	/// <summary>
	/// WebMethod - receiveResponseXML()
	/// Signature: public int receiveResponseXML(string ticket, string response, string hresult, string message)
	/// 
	/// IN: 
	/// string ticket
	/// string response
	/// string hresult
	/// string message
	///
	/// OUT: 
	/// int retVal
	/// Greater than zero  = There are more request to send
	/// 100 = Done. no more request to send
	/// Less than zero  = Custom Error codes
	/// </summary>
	public int receiveResponseXML(string ticket, string response, string hresult, string message)
	{
        logEnter("receiveResponseXML()", new string[,] { { "ticket", ticket }, { "response", response }, { "hresult", hresult }, { "message", message } });
        Session sess = sessionPool.get(ticket);
        if (checkHResult(hresult)) return -101;
        logEvent("Length of response received (in bytes) = " + response.Length);
        int retVal = controller.processLastAction(sess, response);
		sessionPool.put(ticket, sess);
        logExit("receiveResponseXML()", new string[,] { { "retVal", retVal.ToString() } });
        return retVal;
	}



    
    
    [WebMethod(Description = "This web method allows web service to send information about the last error occured during the update process.", EnableSession = true)]
    /// <summary>
	/// WebMethod - getLastError()
    /// Facilitates sending information about the last error occured during the update process.
	/// Signature: public string getLastError(string ticket)
	/// 
	/// IN:
	/// string ticket
	/// 
	/// OUT:
	/// string retVal
	/// Possible Values:
	/// Error message describing last web service error
	/// </summary>
	public string getLastError(string ticket)
	{
        logEnter("getLastError()", new string[,] { { "ticket", ticket } });
        Session sess = sessionPool.get(ticket);
        string retVal=null;
        if (controller.getInteractive(sess)=="NEEDED") {
            retVal = "Interactive mode";
        }
        else{
			retVal="Error!";
		}
        sessionPool.put(ticket, sess);
        logExit("getLastError()", new string[,] { { "retVal", retVal } });
        return retVal;
	}




    
    [WebMethod(Description = "This web method allows web service to send any summary information at the end of a successful update session.", EnableSession = true)]
    /// <summary>
	/// WebMethod - closeConnection()
	/// At the end of a successful update session, QBWebConnector will call this web method.
	/// Signature: public string closeConnection(string ticket)
	/// 
	/// IN:
	/// string ticket 
	/// 
	/// OUT:
	/// string closeConnection result 
	/// </summary>
	public string closeConnection(string ticket)
    {
        logEnter("closeConnection()", new string[,] { { "ticket", ticket } });
        Session sess = sessionPool.get(ticket);
        string retVal=null;
		retVal="OK";
        sessionPool.invalidate(ticket);
        logExit("closeConnection()", new string[,] { { "retVal", retVal } });
        return retVal;
	}



    
    
    [WebMethod(Description = "This web method facilitates web service to send url to QBWC to launch during interactive mode.", EnableSession = true)]
    /// <summary>
    /// WebMethod - getInteractiveURL()
    /// QBWebConnector will call this web method when service indicates that it wants to go interactive.
    /// To go interactive, service has to send empty string for sendRequestXML() and then return "Interactive mode" for getLastError()
    /// Signature: public string getInteractiveURL(string ticket, string sessionid)
    /// 
    /// IN:
    /// string ticket 
    /// string sessionid - ID for the openned session by QBWC to QB
    /// 
    /// OUT:
    /// string url to render in the interactive dialog
    /// </summary>
    public string getInteractiveURL(string wcTicket, string sessionID) {
        logEnter("getInteractiveURL()", new string[,] { { "wcTicket", wcTicket }, { "sessionID", sessionID } });
        Session sess = sessionPool.get(wcTicket);
        controller.putInteractive(sess, sessionID);
        string retVal =null, cState = null;
        if(sess != null) cState=sess.getProperty("lastControllerState").ToString();
        if (cState == "Preflight") {
            retVal = "http://localhost/WCECommSample/service/Preflight.aspx?ticket=" + wcTicket;
        }
        if (cState == "Postflight") {
            retVal = "http://localhost/WCECommSample/service/Postflight.aspx?ticket=" + wcTicket+"&sessionID="+sessionID;
        }
        sessionPool.put(wcTicket, sess);
        logExit("getInteractiveURL()", new string[,] { { "retVal", retVal } });
        return retVal;
    }


    
    
    
    
    [WebMethod(Description = "This web method facilitates web service to let QBWC know if interactive session has ended or not.", EnableSession = true)]
    /// <summary>
    /// WebMethod - isInteractiveDone()
    /// QBWebConnector will call this web method every 60 seconds for service to indicate if interactive session is completed by user.
    /// Signature: public string isInteractiveDone(string ticket)
    /// 
    /// IN:
    /// string ticket 
    /// 
    /// OUT:
    /// string resp 
    ///     - DONE = QBWC responds by calling closeConnection()
    ///     - CONTINUE = QBWC responds by calling sendRequestXML() and resuming the normal sequence
    ///     - <empty string> = QBWC waits another 60 seconds (default wait time before interactiveDone() call) and checks again
    ///     - <any other string> = QBWC presents the error, closeConnection() is called
    /// </summary>
    public string isInteractiveDone(string wcTicket) {
        logEnter("isInteractiveDone()", new string[,] { { "wcTicket", wcTicket} });
        Session sess = sessionPool.get(wcTicket);
        string retVal = null, status = null;
        //Check status of ecommdb->interactive->interactiveMode 
        //Respond with retVal based on status of interactiveMode
        if(sess != null) {
            status=controller.getInteractive(sess);
        }
        if (status== "DONE") {
            //Clear the record from database and move on
            controller.removeInteractive(sess);
            retVal = "CONTINUE";
        }
        else if (status== "CANCELLED" || status== "TIMEDOUT") {
            //No need to proceed with this update
            controller.removeInteractive(sess);
            retVal = "User cancelled this update session or it timedout.";
        }
        else {
            //Keep interactive session going.
            retVal = ""; 
        }
        sessionPool.put(wcTicket, sess);
        logExit("isInteractiveDone()", new string[,] { { "retVal", retVal } });
        return retVal;
    }


    
    
    
    
    [WebMethod(Description = "This web method facilitates web service to know if QBWC rejected this interactive session and why.", EnableSession = true)]
    /// <summary>
    /// WebMethod - interactiveRejected(string wcTicket, string reason)
    /// QBWebConnector will call this web method to notify the service if interactive session was rejected and why.
    /// Signature: public string interactiveRejected(string wcTicket, string reason)
    /// 
    /// IN:
    /// string wcTicket
    /// string reason
    /// 
    /// OUT:
    /// string resp 
    ///     - DONE = QBWC responds by calling closeConnection()
    ///     - CONTINUE = QBWC responds by calling sendRequestXML() and resuming the normal sequence
    ///     - <empty string> = QBWC waits another 60 seconds (default wait time before interactiveDone() call) and checks again
    ///     - <any other string> = QBWC presents the error, closeConnection() is called
    /// </summary>
    public string interactiveRejected(string wcTicket, string reason) {
        logEnter("interactiveRejected()", new string[,] { { "wcTicket", wcTicket }, { "reason", reason } });
        Session sess = sessionPool.get(wcTicket);
        string retVal = null, status = null; 
        //Checking status of ecommdb->interactive->interactiveMode 
        //Responding with retVal based on status of interactiveMode
        if (sess != null) controller.getInteractive(sess);
        if (status== "DONE") {
            //Clearing the record from database and move on
            if (sess != null) controller.removeInteractive(sess);
            retVal = "CONTINUE";
        }
        else if (status== "CANCELLED" || status== "TIMEDOUT") {
            //No need to proceed with this update
            if (sess != null) controller.removeInteractive(sess);
            retVal = "User cancelled this update session or it timedout.";
        }
        else {
            //Keeping interactive session going.
            retVal = ""; 
        }
        sessionPool.put(wcTicket, sess);
        logExit("interactiveRejected()", new string[,] { { "retVal", retVal } });
        return retVal;
    }

	
    
    
    
    
    //UtilityMethods
	private void initEvLog()
		{
			string source="WCWebService";
			if (!System.Diagnostics.EventLog.SourceExists(source))
				System.Diagnostics.EventLog.CreateEventSource(source, "Application");
			evLog.Source = source;
			return;
		}
		
    private void logEvent(string logText)
		{
            if (!doLogging) return;
			evLog.WriteEntry(logText);
			return;
		}
        
    private void logEnter(string webMethodName, string[,] parameters) {
            if (!doLogging) return;
            string evLogTxt = "WebMethod: " + webMethodName +" has been called " +
                        "by QBWebconnector" + "\r\n\r\n";
            evLogTxt = evLogTxt + "Parameters received:\r\n";
            logParameters(parameters, evLogTxt);
        }
        
    private void logExit(string webMethodName, string[,] parameters) {
            if (!doLogging) return;
            string evLogTxt = "WebMethod: " + webMethodName + " returned following values" +
                        "to QBWebconnector" + "\r\n\r\n";
            evLogTxt = evLogTxt + "Values returned:\r\n";
            logParameters(parameters, evLogTxt);
        }
        
    private void logParameters(string[,] parameters, string evLogTxt) {
            int length = parameters.GetLength(0);
            for (int i = 0; i < length; i++) {
                if (parameters[i, 0] != null) {
                    evLogTxt = evLogTxt + parameters[i, 0] + "\r\n"; //parameter name
                    evLogTxt = evLogTxt + parameters[i, 1] + "\r\n"; //parameter value
                }
            }
            logEvent(evLogTxt);
        }
		
    private string parseForVersion(string input){
			// This method is created just to parse the first two version components
			// out of the standard four component version number:
			// <Major>.<Minor>.<Release>.<Build>
			// 
			// As long as you get the version in right format, you could use
			// any algorithm here. 
			string retVal="";
			string major="";
			string minor="";
			Regex version = new Regex(@"^(?<major>\d+)\.(?<minor>\d+)(\.\w+){0,2}$", RegexOptions.Compiled);
			Match versionMatch= version.Match(input);
			if (versionMatch.Success){
				major= versionMatch.Result("${major}");							
				minor= versionMatch.Result("${minor}");							
				retVal=major+"."+minor;
			}
			else{
				retVal=input;
			}
			return retVal;
		}
        
    private string interpretHResult(string hresult, string message, int ce_counter) {
            string retVal = null;
            // Here are some example error codes used. 
            // 0x80040400 - QuickBooks found an error when parsing the provided XML text stream. 
            const string QB_ERROR_WHEN_PARSING = "0x80040400";
            // 0x80040401 - Could not access QuickBooks.  
            const string QB_COULDNT_ACCESS_QB = "0x80040401";
            // 0x80040402 - Unexpected error. Check the qbsdklog.txt file for possible, additional information. 
            const string QB_UNEXPECTED_ERROR = "0x80040402";
            // Add more as you need...
            switch (hresult.Trim()) {
                case QB_ERROR_WHEN_PARSING:
                    logEvent("HRESULT = " + hresult + "\r\n" + "Message = " + message);
                    retVal = "DONE";
                    break;
                case QB_COULDNT_ACCESS_QB:
                    logEvent("HRESULT = " + hresult + "\r\n" + "Message = " + message);
                    retVal = "DONE";
                    break;
                case QB_UNEXPECTED_ERROR:
                    logEvent("HRESULT = " + hresult + "\r\n" + "Message = " + message);
                    retVal = "DONE";
                    break;
                default:
                    if (ce_counter == 0) {
                        logEvent("HRESULT = " + hresult + "\r\n" + "Message = " + message);
                        logEvent("Sending empty company file to try again.");
                        retVal = ""; // Means try again with this company file
                    }
                    else {
                        logEvent("HRESULT = " + hresult + "\r\n" + "Message = " + message);
                        logEvent("Sending DONE to stop.");
                        retVal = "DONE";
                    }
                    break;
            }
            return retVal;
        }
        
    private bool checkHResult(string hresult) {
            if (hresult.ToString().Equals("")) {
                return false;
            }
            else {
                return true;
            }
        }
        
    private string[] initAuthResponse() {
            // Code below uses a random GUID to use as session ticket
            // An example of a GUID is {85B41BEE-5CD9-427a-A61B-83964F1EB426}
            return setAuthResponse(System.Guid.NewGuid().ToString(), null);
        }
    
    private string[] setAuthResponse(string ticket, string cfn) {
            string[] authRet = new string[2];
            if(ticket!=null) authRet[0] = ticket;
            if(cfn!=null) authRet[1] = cfn;
            return authRet;
        }
        
    private void checkWork(ref string[] authReturn, Session sess) {
            if (controller.haveAnyWork(sess)) {
                authReturn[1] = ""; // Use currently open QB file
            }
            else {
                authReturn[0] = "";
                authReturn[1] = "none";
            }
        }
    
    private void doAuthenticate(string strUserName, string strPassword, ref string[] authReturn) {
        authenticator.CreateAuthentication(null);
        authReturn[0]=(string)authenticator.authenticate(strUserName, strPassword, db);
        return;
    }
}
